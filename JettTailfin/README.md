# Stack overflows in "Jett Tailfin"

By manipulating the `common_wiiu_json.bin` (or any other `xxx_json.bin`) file we can achieve a (limited) rop-chain execution.

## How it works

The games loads texture information from binary files called `xxx_json.bin`. The struct look something like this.
```
struct BinaryTextureJSON{
    uint32_t numberOfTextures;
    TextureInformation textures[];
    [...]
};

struct TextureInformation { // Size of this is 0x100
    char filepath[];    // path to .gtx file
    [...]               // Other information we really don't care about
};
// 
```

The parser first reads the number of textures, then each texture information one by one.

```
void Screen::readBinary(WiiUFile * binary) {
    [...]
    uint32_t numberTextures;
    binary->read(0x4, &numberTextures);
    if(numberTextures > 0) {
        for(int i = 0; i < numberTextures; i++) {
            TextureInformation textureInfo;
            binary->read(0x100, &textureInfo);
            addTexture(&textureInfo);
        }
    }
    [...]
}
```
After one texture information is read, it will be added. When adding, the first thing that happens it the actual loading of the image.
```
Screen::addTexture(void * this, TextureInformation * textureInfo) {
    [...]
    ImageLoaderManager::getInstance()->loadImage(textureInfo)
    [...]
}
```

But before the image is loaded, the file type/ending is determined. 
```
ImageLoaderManager::loadImage(TextureInformation * textureInfo) {
    char fileEnding[16];
    int i = 0;
    int lastDotOffset = 0;
    while(true) {
        if(textureInfo->filepath[i] == '\0') {
            break;
        }
        if(textureInfo->filepath[i] == '.') {
            lastDotOffset = i + 1;
        }
        i++;
    }
    strcpy(fileEnding, textureInfo->filepath + lastDotOffset); // ouch
}
```

In the loadImage function it's tries to copy the file ending to a fixed char array on the stack. If we craft a TextureInformation with a long filepath which does NOT contain a '.', the whole string is copied to the stack and causes a stack overflow. This give us easy rop-chain execution :)

## Limitations
Due to this bug we can copy 0x100 bytes to the stack. Out of these 0xDC bytes can be used for the rop-chain. This might be enough to load more data and/or do a stack pivot to memory we can fully control. The only "problem": the payload must not contain '\0' or '.'.

## Usage

This has been tested with Jett Tailfin (USA, 00050000-1012cd00)

- Generate a `common_wiiu_json.bin` via `python ./generate.py`
- Copy the file to `/content/Jett/resources/WiiU/Interfaces/common_wiiu_json.bin`
- Start the game
- wait :)

# `ChampionshipData.cfg` bug
There is another exploitable stack overflow in this game. 
The file `/content/Jett/resources/WiiU/Interfaces/ChampionshipData.cfg` contains strings that will be copied to the stack without any length check. Limitation: the copied string must not contain bytes < 0x20 which limited the rop-chain.